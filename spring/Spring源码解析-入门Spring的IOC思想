《Spring源码解析-入门Spring的IOC思想》首发[橙寂博客](http://www.luckyhe.com/post/80.html)转发请加此提示

## Spring源码解析-入门Spring的IOC思想

#### 1.引入

大家在面试的时候，应该都会碰到这么一个问题。请浅谈一下`Spring IOC`(控制反转)思想?或者是解释下什么是`DI`(依赖注入)?。本篇会从`Spring官方文档`的角度,结合自己的工作经验
，给大家讲一下自己对`Spring`的一些理解。


#### 2.概述

`Spring Core`是`Spring`的核心。而`Spring`的核心讲的就是一个`IOC`思想。`Spring`的`IOC`容器管理着是一个或者多个`Bean`。在一个`Spring`应用启动,`Spring`会根据我们提供的元数据。
做一个`自省`的过程。当我们真正用一些`Bean`时。这时我们可以通过注解（@Autowired）的方式或者是主动调用`ApplicationContext`的`getBean()`方法根据标识符（Id或者带包名的类名）从容器中取得我们想要的
`Bean`对象。这就是`IOC`也叫做`DI`。

当然在容器中每个`Bean`都是有个唯一的`Id`的，如果我们不显示的提供,`Spring`会根据Java的规范默认按照驼峰命名法命名（首字母小写）。(例如:postService,postDao)

#### 3.配置元数据

如果想`Spring`去管理`Bean`那么你就得告诉`Spring`你需要管理的`Bean`。这个过程叫做配置元数据。配置元数据有两中方式。
每个`Bean`在`Spring`中被定义成了`BeanDefinition`这个对象里面保存我们这个`Bean`的一些基本属性：

1. 带包名的类名
2. 其他类的引用
3. 管理`bean`的连接池的的大小,或者连接数。
4. 其他一些行为。比如`Bean`的作用域。

##### 3.1配置`Bean`的两种方式

- 注解

在我们的日常工作中,我们会使用

```java
@Commpont

@Service

@Configuration
//代表这是一个配置类
public class QuartzConfig {

    /**
     * 往容器中初始注入scheduler
     * @return
     * @throws SchedulerException
     */
    @Bean
    public Scheduler scheduler() throws SchedulerException{
        SchedulerFactory schedulerFactoryBean = new StdSchedulerFactory();
        return schedulerFactoryBean.getScheduler();
    }
}

```
以上注解都是告诉`Spring`我需要将带这些注解的`Bean`教给`Spring`容器管理。除了这个具体每个注解带的含义是不一样的。有想要了解的自己去了解下。


- xml配置

dao.xml
```java

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>

```
以上是一个`Dao`的配置文件。接下来程序去加载这个文件就好了。

```java

//这里可以加载多个文件,分隔。
ApplicationContext context = new ClassPathXmlApplicationContext("daos.xml");

// retrieve configured instance
JpaAccountDao dao = context.getBean("accountDao");

// use configured instance
List<String> userList = dao.getUsernameList();

```


#### 依赖注入（DI）

元数据配置好了，但是通常在我们日常的使用中我们的`Bean`肯定是依赖了其他`Bean`的。
比如一个`Controller`中需要注入`Service`等等。
所以在配置的时候我们就需要把需要依赖的类(或属性)注入进去。

- xml配置

构造方式的形式注入`Bean`
```java
package x.y;

//构造方式的形式注入
public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}

<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>

```
构造方式的形式注入属性

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}

//第一种方式
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>

//第二种方式

<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>


```

`Setter`方式注入

```java

public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}

<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>


```

- 注解方式注入

这种方式应该是目前用的最多的一种形式。特别是在`SpringBoot`项目中,抛弃`xml`配置的方式,全局使用了注解的方式。
（题外话:SpringBoot中的自动装配机制其实跟`Spring`的机制是相通的。Springboot内置了一些自动装配的配置类。所以只需要改改配置文件。就能自动注入我们需要类）

当你想要在你的`Bean`中使用`@Autoried`  `@Resource(name = "bean的名字")`注入您需要的`Bean`。
你一定要确定`Bean`一定要存在于容器中。（也就是说一定要先提供的元数据）。

下面讲几个在日常开发中经常会用到的例子

```java

@Controller
public class BaseController
{
	//系统用户
	@Autowired
	public SysUserService sysUserService;


  //这个name一定是你配置的名字，如果你没配那么默认是首字母小写
  @Resource(name = "sysPermissionService")
  public SysPermissionService sysPermissionService;
  }


```



```java
Lock lock = new ReentrantLock
lock.lock();
try{
}finally{
 lock.unlock();
}
```

Lock接口提供了Synchronized关键字不具备的特性

| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，没有其他线程获取锁，则成功 |
| --------- | ----------------------- |
| 能被中断的获取锁  |                         |
| 超时获取锁     | 在指定的时间内获取锁              |

Lock接口的API

| api                          |                                          |
| ---------------------------------------- | ---------------------------------------- |
| void lock()                    | lock 优先考虑获取锁，待获取锁成功后，才响应中断。|
| void lockInterruptibly() throws InterruptedException |  lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。
                                        |
| boolean tryLock()                        |     同Lock                                    |
| boolean tryLock(long time,TimeUtil unit) throws InterruptedException |    在一定时间time内尝试获取锁                                     |
| void unlock()                            |       释放锁                                   |
| Condition newCondition                   | 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait（）方法，而调用后，当前线程将会释放锁 |


#### 队列同步器AbstractQueuedSynchronized

上面介绍的是ReentrantLock中的api,最主要的事是`AbstractQueuedSynchronized`在做。

锁的实现基于队列同步器完成，AbstractQueuedSynchronized（简称同步器），使用一个int成员变量state表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作
队列同步器分两种一种是`NonfairSync`非公平锁默认是用非公平方式,另一种是`FairSync`公平锁。


#### NonfairSync实现

所谓非公平，讲的是获取锁的方式不公平。排队买票，按理说先来先买，但是在这里每个新来的人都能跟你抢票。下面看源码的实现。
下面代码为我调用Lock方法时执行的一个顺序。其中有些方法不属于`NonfairSync`

```java

   /**
    * Sync object for non-fair locks
    */
   static final class NonfairSync extends Sync {
       private static final long serialVersionUID = 7316153563782823691L;

       /**
        * Performs lock.  Try immediate barge, backing up to normal
        * acquire on failure.
        */
       final void lock() {
            //尝试着获取锁 这里也是不公平的体现，刚进来就有机会获取锁
           if (compareAndSetState(0, 1))
               setExclusiveOwnerThread(Thread.currentThread());
           else

               acquire(1);
       }


       /**
        *
        * 调用这个方法首先会尝试获取锁，如果获取不到会把当前线程加入等待列中
        */
       public final void acquire(int var1) {
           //this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), var1)
           //这个方法把当前线程加入等待序列。具体代码自己去看。
            if (!this.tryAcquire(var1) && this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), var1)) {
                selfInterrupt();
            }


       protected final boolean tryAcquire(int acquires) {
           return nonfairTryAcquire(acquires);
       }


       /**
        * Performs non-fair tryLock.  tryAcquire is implemented in
        * subclasses, but both need nonfair try for trylock method.
        *尝试获取锁
        */
       final boolean nonfairTryAcquire(int acquires) {

           //获取当前
           final Thread current = Thread.currentThread();
           //当前锁的占用量
           int c = getState();
           if (c == 0) {
           //如果没有人用这个锁尝试获取锁
               if (compareAndSetState(0, acquires)) {
                   setExclusiveOwnerThread(current);
                   return true;
               }
           }
           else if (current == getExclusiveOwnerThread()) {
               int nextc = c + acquires;
               if (nextc < 0) // overflow
                   throw new Error("Maximum lock count exceeded");
               setState(nextc);
               return true;
           }
           return false;
       }

   }
```

#### FairSync实现

所谓非公平，讲的是获取锁的方式不公平。排队买票，先来先买
下面代码为我调用Lock方法时执行的一个顺序。其中有些方法不属于`NonfairSync`

```java

static final class FairSync extends Sync {
       private static final long serialVersionUID = -3000897897090466540L;

       final void lock() {
           acquire(1);
       }

       /**
        *
        * 调用这个方法首先会尝试获取锁，如果获取不到会把当前线程加入等待列中
        */
       public final void acquire(int var1) {
           //this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), var1)
           //这个方法把当前线程加入等待序列。具体代码自己去看。
            if (!this.tryAcquire(var1) && this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), var1)) {
                selfInterrupt();
            }

       /**
        * Fair version of tryAcquire.  Don't grant access unless
        * recursive call or no waiters or is first.
        */
       protected final boolean tryAcquire(int acquires) {
           final Thread current = Thread.currentThread();
           int c = getState();
           if (c == 0) {
           //这里是跟非公平锁不一样的地方
           //hasQueuedPredecessors判断线程是不是在队列中的第一个
           //只有第一个才有资格去抢
               if (!hasQueuedPredecessors() &&
                   compareAndSetState(0, acquires)) {
                   setExclusiveOwnerThread(current);
                   return true;
               }
           }
           else if (current == getExclusiveOwnerThread()) {
               int nextc = c + acquires;
               if (nextc < 0)
                   throw new Error("Maximum lock count exceeded");
               setState(nextc);
               return true;
           }
           return false;
       }
   }
```

##### release方法同unLock

字面意思释放锁，unpark掉当前线程。

```java

/**
 * Releases in exclusive mode.  Implemented by unblocking one or
 * more threads if {@link #tryRelease} returns true.
 * This method can be used to implement method {@link Lock#unlock}.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryRelease} but is otherwise uninterpreted and
 *        can represent anything you like.
 * @return the value returned from {@link #tryRelease}
 */
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}


/**
   * Wakes up node's successor, if one exists.
   *
   * @param node the node
   */
  private void unparkSuccessor(Node node) {
      /*
       * If status is negative (i.e., possibly needing signal) try
       * to clear in anticipation of signalling.  It is OK if this
       * fails or if status is changed by waiting thread.
       */
      int ws = node.waitStatus;
      if (ws < 0)
          compareAndSetWaitStatus(node, ws, 0);

      /*
       * Thread to unpark is held in successor, which is normally
       * just the next node.  But if cancelled or apparently null,
       * traverse backwards from tail to find the actual
       * non-cancelled successor.
       */
      Node s = node.next;
      if (s == null || s.waitStatus > 0) {
          s = null;
          //从尾节点往前找，找到合适的然后干掉
          for (Node t = tail; t != null && t != node; t = t.prev)
              if (t.waitStatus <= 0)
                  s = t;
      }
      if (s != null)
          LockSupport.unpark(s.thread);
  }


```

## 使用案例

#### 条件锁 Condition

Condition是针对于对象的，`ReentrantLock`是针对于线程的。

部分方法描述

| void await()                       | 当前线程进入等待状态，直到被通知或中断。                      |
| ---------------------------------- | ---------------------------------------- |
| void awaitUninterruptibly()        | 当前线程进入等待状态，对中断不敏感                        |
| long awaitNanos(long nanosTimeout) | 当前线程进入等待状态，直到被通知，中断或者超时，返回值表示剩余的时间，返回值如果是0或者负数，那么可以认定已经超时了 |
| boolean awaitUntil(Date deadline)  | 当前线程进入等待状态，直到被通知、中断或者到某个时间，如果没有到指定时间，返回true，否则到了指定时间，返回false |
| void signal()                      | 唤醒一个等待在condition中的线程，该线程从等待方法返回前必须获取与Condition相关联的锁 |
| void signlAll()                    | 唤醒所有等待的condition中的线程，能够从等待方法返回的线程必须获得与condition相关联的锁 |

```java
public class ConditionUseCase {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public static void main(String[] args){

    }

    public void conditionWait() throws InterruptedException {
        lock.lock();
        try {
            condition.await();
        }finally {
            lock.unlock();
        }
    }
    public void conditionSignal(){
        lock.lock();
        try {
            condition.signal();
        }finally {
            lock.unlock();
        }
    }
}
```


通过Cache来解释读写锁，HashMap是非线程安全的，通过读写锁实现Cache的线程安全

```java
public class Cache {
    static Map<String,Object> map = new HashMap<String,Object>();
    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    static Lock r = rwl.readLock();
    static Lock w = rwl.writeLock();

    public static final Object get(String key){
        r.lock();
        try {
            return map.get(key);
        }finally {
            r.unlock();
        }
    }

    public static final Object put(String key,Object value){
        w.lock();
        try {
            return map.put(key,value);
        }finally {
            w.unlock();
        }
    }

    public static final void clear() {
        w.lock();
        try {
            map.clear();
        }finally {
            w.unlock();
        }
    }

}
```

- 有界队列BoundedQueue解释Condition

```java
public class BoundedQueue<T> {
    private Object[] items;
    private int addIndex,removeIndex,count;
    private Lock lock = new ReentrantLock();
    private Condition notEmpty = lock.newCondition();
    private Condition notFull = lock.newCondition();

    public BoundedQueue(int size){
        items = new Object[size];
    }

    public void add(T t) throws InterruptedException {
        lock.lock();
        try {
            while(count == items.length)
                notFull.await();
            items[addIndex] = t;
            if(++addIndex == items.length)
                addIndex = 0;
            ++count;
            notEmpty.signal();
        }finally {
            lock.unlock();
        }
    }

    public T remove() throws InterruptedException {
        lock.lock();
        try {
            while(count == 0)
                notEmpty.await();
            Object x = items[removeIndex];
            if(++removeIndex == items.length)
                removeIndex = 0;
            --count;
            notFull.signal();
            return (T) x;
        }finally {
            lock.unlock();
        }

    }
}
```

## 总结

`ReentrantLock`的讲解就到此结束,看博客前希望自己看过一点源码。如果没看过的话那么请重点关注我提出来的那几个代码。如果对于这个`ReentrantLock`想要更深的理解。请关注
[simviso](https://space.bilibili.com/2494318/dynamic)
