---
  title: 23个设计模式之命令模式
  date: {{ date }}   
  categories: ['后端']
  tags: ['Java','设计模式']       
  comments: true    
  img:             
---
## 序言
这篇文章是作者看完《大话设计模式》（写的很好对于小白来说也很好理解）一书写的。引用了部分作者书中的内容，并加以自己的了解写的文章。23个设计模式其实就是写代码写得多的套路，我记得作者以前软考时也大致看过。但是那时的感悟并不深。结合了工作的经验后，再来学设计模式。感觉自己也已经初入门道。因此写下了这篇全集，解析错误之处欢迎大家指正。

个人认为学习设计模式的目的只有一个，那就是写出高质量的代码。并不是把设计模式背下来，然后当做宝贝似的。
## 类图
我的文章中大多都是以类图去描述的，所以必须学会看类图。类图是个好东西，看程序的话会一目了然的。

## 设计模式的六大原则
#### 单一职责原则

###### 单一职责的特点
对于这个原则书上是这样说的：**对于一个类而言，应该仅有一个引起它变化的原因**。换个通俗的语言来说，就是一个类只做自己的分内之事。就拿mvc分成来说的，view就是负责显示数据，model层负责封装数据，control层负责跟视图层跟model层交互。这也是在软件设计中为什么提倡mvc模式。如果不分层把所有代码写在一个类中，到时维护起来会有多么麻烦。这就是单一职责模型的最好的诠释了。
其实在软件设计中，大部分都在做一件事就是**划分职责**。最重要的也最难的就是划分职责。

#### 开放封闭原则
 #### 开放封闭的特点
 这个原则其实有两个特征，对**扩展开放**，对**更改封闭**的。
 所以在程序中对于程序的设计要思考清楚，如果每次增加新功能都需要去修改原有的代码，那么便不符合，开放封闭原则。在程序中有新功能就新增代码，而不是修改原有的代码。这就是开放封闭的灵魂。

######  开放封闭原则的优点
1. 可维护
2. 可扩展
3. 可复用
4. 灵活性好

（样例）
 ![e768cb57cdb49e449e1b1145aacd8245.png](en-resource://database/512:1)
 当然要拒绝不成熟的抽象，并不是每个都去抽象它。
#### 依赖倒置原则

###### 依赖倒置的特点
 官方是这样解释的：**抽象不应该依赖细节，细节依赖于抽象**。换做通俗的话来说就是**面向接口编程**。
 - 依赖倒置的原则
 1. 高层模块不应该依赖于低层模块。两个都要依赖于抽象。
 2. 抽象不应该依赖于细节，细节依赖于抽象。
 简单来说，就是你高层的代码，不应该依赖于地层的代码。应该依赖抽象接口或者类。不管需求怎么改。我们只需要修改具体的实现细节就行了。这就好比修电脑，内存条坏了换内存条就行，不应该说是把主板也换了。
#### 里式代换原则
###### 依赖倒置的特点
 官方是这样解释的：**子类型必须能够完全替代父类型**。这是**继承**的原则简单来说就是父类的东西子类必须有，在面向对象的设计中比如父类有个飞的方法，但是子类是个不能飞的东西。这就违反了这个原则！！！
 看个图理解下
 ![fe88e2327aab6c2fe236116e1338ef96.png](en-resource://database/514:1)

 #### 再看依赖倒置原则
 正是由于子类的可替换性，才使得不用修改父类模块的情况下就可以扩展。如果不依赖于这个原则，那谈什么**开源-封闭**。
 这时候我们再来看看依赖倒置，不管是高层还是低层都依赖于抽象。看完这个应该更能理解依赖倒置原则了吧。如果代码不符合**里式代换原则**那么**依赖倒置**也是白谈了。所以依赖倒置大家谁都不依赖谁，除了约定接口外，自由发挥。
 ![1234b8a00f773b0c77e2a699c052375c.png](en-resource://database/516:1)
#### 合成复用原则
###### 合成复用的特点
这个原则的本质就是不要过多的依赖继承，尽量使用**合成**（合成是一种强强拥有关系，表示部门与整体之间的关系。）或者**聚合**（聚合是一种弱拥有关系，可以这么理解就是a对象可以包含B对象但是b对象不a对象的一部分。）
看个图理解下。
 ![e369c7d5e64f810ebc1e021f6ee4ceed.png](en-resource://database/518:1)
###### 为什么使用合成复用原则
 假设目前正在做一个数据库的连接功能，需要支持多种数据库，这时大家的想法肯定都是写一个操作类，然后具体实现类继承这个方法。这个思路是对的。但并不是继承就一定好如果有一天万不得以，我需要修改的类的一个方法。这时是不是所有的实现类都需要去修改。这就有点**牵一发而动全身**。但是如果使用的是**合成复用原则**就不一样了。不管怎么改，我的实现类都是不需要去修改的。这样做其实也是解耦的一种方法。在程序中要遵循这个原则尽量少与人联系，以免遭到无妄之灾。

#### 迪米特原则
###### 迪米特的特点
官方解释：如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用。如果其中一个类调用其中的一个方法的话，应该通过第三者来转发。

###### 为什么使用迪米特原则
 在类的设计上，不必让第三者知道的字段或者方法封装好。迪米特原则的根本思想就是强调类之间的松耦合。类之间的耦合越弱越利于复用。一个弱耦合的类被修改，也不会对别的类造成波及。

## 接口隔离原则

这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

如果对于这个六个原则理解已经很深了，那么你的代码质量应该是非诚高的。

## 23个设计模式

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代模式、职责链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

每个模式我都以单独的博文的形式写出来

#### 创建型模式

- [工厂方法模式]()
- [抽象工厂模式]()
- [单例模式]()
- [原型模式]()
- [建造者模式]()

#### 结构型模式

- [适配器模式]()
- [装饰器模式]()
- [代理模式]()
- [外观模式]()
- [桥接模式]()
- [组合模式]()
- [享元模式]()

#### 行为型模式

- [策略模式]()
- [模板方法模式]()
- [观察者模式]()
- [迭代模式]()
- [职责链模式]()
- [命令模式]()
- [备忘录模式]()
- [状态模式]()
- [访问者模式]()
- [中介者模式]()
- [解释器模式]()


## 总结

设计模式就是代码写的多的套路，看懂这些模式很简单，但是学以制用才是本事。作为初学者还是要多去看别人优秀的代码怎么写的。个人认为学习设计模式的目的只有一个，那就是写出高质量的代码。
