## 序言

滴，下班打卡成功。苦逼的一年终于结束了，明天就回家过年了。回想自己2020年一年感慨万分，差点就猛男落泪了。
## 简介
96年的苦逼程序员一枚，正式工作三年了，目前在一家创业型公司。

主要工作：框架搭建，项目管理，需求调研，任务分配，码代码，写前端，做运维，带新人...（感觉公司是我自己开的）

工作城市:自称二线城市的NC市

志向:为老板早日住豪宅开豪车泡模特而奉献自己的一生。



## 回顾2020
时间过的真尼玛快啊，时间感觉吧不得马上把我拉入中年男人的这个阶层，也在无时无刻不在提醒我，你咋还没结婚，你怎么还在骑单车，你怎么还在租房子。这时候真想大唱一首：时光时光慢些吧，不要让我在变老了。

言归正传,整个2020年不管是工作还是生活都有点操蛋。

#### 工作

做了一年多的公司离职了，主要原因是老板开不下去了，拖欠了一年社保，工作也好几个月没发。与资本家斗智斗勇真是门技术活，真实的演绎出了爱哭的孩子才有糖吃这么一点。由于我吵着要去仲裁，公司在离职后2个月补齐了我半年工资以及一年社保，还有6000多绩效没发（估计是不可能发了）。等了大半年还没等到上家倒闭的消息（听说公司活过来了，但是还拖欠一点工资）。

离职后，上家经理推荐我来了一家创业型公司，领导自己说也要来的，结果自己了解好了情况下，自己跑去国企了。本来我也不想呆创业公司的，因为创业公司一个很明显的特征就是钱少事多。诸多因素吧，我还是留了下来。果不其然，这是一家996的公司，老板对我寄予厚望，也挺认可我的能力的，然后我就主要负责了这些事:**框架搭建，项目管理，需求调研，任务分配，码代码，写前端，做运维，带新人**既来之则安之吧，**钱不钱的无所谓了，主要我喜欢吃饼**。

但是总的一年来，我觉得我承担的事多了，休息时间少了，技术确一点没涨。根据跟前两年比能明显的感觉到成长变慢了。从博客数量就能明显看出2020年整年才发了2篇，而2019年发了40多篇。当然随着自己技术经验的增长，越来越感觉到**crud**最终走向的就是坟墓。当然很多人的想法可能是做管理，但我想说的是做了管理又如何呢？？？你能做到老嘛？你能拿到公司的股份嘛？？？如若不能那么当你不能加班的那天，就是走向坟墓的那天。技术人还是要守住自己做技术这门饭碗，很多技术大佬真就是能做到目前大部分人学的技术都是没有深度的，能写crud并不代表你不可替代。如若你能开发**netty**这种级别的源码，你还会担心失业嘛？认清现实吧少年。我感觉自己得收回初心了，还是得往基础研发走。

#### 开放封闭原则
 #### 开放封闭的特点
 这个原则其实有两个特征，对**扩展开放**，对**更改封闭**的。
 所以在程序中对于程序的设计要思考清楚，如果每次增加新功能都需要去修改原有的代码，那么便不符合，开放封闭原则。在程序中有新功能就新增代码，而不是修改原有的代码。这就是开放封闭的灵魂。

######  开放封闭原则的优点
1. 可维护
2. 可扩展
3. 可复用
4. 灵活性好

（样例）
 ![e768cb57cdb49e449e1b1145aacd8245.png](en-resource://database/512:1)
 当然要拒绝不成熟的抽象，并不是每个都去抽象它。
#### 依赖倒置原则

###### 依赖倒置的特点
 官方是这样解释的：**抽象不应该依赖细节，细节依赖于抽象**。换做通俗的话来说就是**面向接口编程**。
 - 依赖倒置的原则
 1. 高层模块不应该依赖于低层模块。两个都要依赖于抽象。
 2. 抽象不应该依赖于细节，细节依赖于抽象。
 简单来说，就是你高层的代码，不应该依赖于地层的代码。应该依赖抽象接口或者类。不管需求怎么改。我们只需要修改具体的实现细节就行了。这就好比修电脑，内存条坏了换内存条就行，不应该说是把主板也换了。
#### 里式代换原则
###### 依赖倒置的特点
 官方是这样解释的：**子类型必须能够完全替代父类型**。这是**继承**的原则简单来说就是父类的东西子类必须有，在面向对象的设计中比如父类有个飞的方法，但是子类是个不能飞的东西。这就违反了这个原则！！！
 看个图理解下
 ![fe88e2327aab6c2fe236116e1338ef96.png](en-resource://database/514:1)

 #### 再看依赖倒置原则
 正是由于子类的可替换性，才使得不用修改父类模块的情况下就可以扩展。如果不依赖于这个原则，那谈什么**开源-封闭**。
 这时候我们再来看看依赖倒置，不管是高层还是低层都依赖于抽象。看完这个应该更能理解依赖倒置原则了吧。如果代码不符合**里式代换原则**那么**依赖倒置**也是白谈了。所以依赖倒置大家谁都不依赖谁，除了约定接口外，自由发挥。
 ![1234b8a00f773b0c77e2a699c052375c.png](en-resource://database/516:1)
#### 合成复用原则
###### 合成复用的特点
这个原则的本质就是不要过多的依赖继承，尽量使用**合成**（合成是一种强强拥有关系，表示部门与整体之间的关系。）或者**聚合**（聚合是一种弱拥有关系，可以这么理解就是a对象可以包含B对象但是b对象不a对象的一部分。）
看个图理解下。
 ![e369c7d5e64f810ebc1e021f6ee4ceed.png](en-resource://database/518:1)
###### 为什么使用合成复用原则
 假设目前正在做一个数据库的连接功能，需要支持多种数据库，这时大家的想法肯定都是写一个操作类，然后具体实现类继承这个方法。这个思路是对的。但并不是继承就一定好如果有一天万不得以，我需要修改的类的一个方法。这时是不是所有的实现类都需要去修改。这就有点**牵一发而动全身**。但是如果使用的是**合成复用原则**就不一样了。不管怎么改，我的实现类都是不需要去修改的。这样做其实也是解耦的一种方法。在程序中要遵循这个原则尽量少与人联系，以免遭到无妄之灾。

#### 迪米特原则
###### 迪米特的特点
官方解释：如果两个类不必彼此直接通信，那么两个类就不应该发生直接的相互作用。如果其中一个类调用其中的一个方法的话，应该通过第三者来转发。

###### 为什么使用迪米特原则
 在类的设计上，不必让第三者知道的字段或者方法封装好。迪米特原则的根本思想就是强调类之间的松耦合。类之间的耦合越弱越利于复用。一个弱耦合的类被修改，也不会对别的类造成波及。

## 接口隔离原则

这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。

如果对于这个六个原则理解已经很深了，那么你的代码质量应该是非诚高的。

## 23个设计模式

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代模式、职责链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

每个模式我都以单独的博文的形式写出来

#### 创建型模式

- [工厂方法模式]()
- [抽象工厂模式]()
- [单例模式]()
- [原型模式]()
- [建造者模式]()

#### 结构型模式

- [适配器模式]()
- [装饰器模式]()
- [代理模式]()
- [外观模式]()
- [桥接模式]()
- [组合模式]()
- [享元模式]()

#### 行为型模式

- [策略模式]()
- [模板方法模式]()
- [观察者模式]()
- [迭代模式]()
- [职责链模式]()
- [命令模式]()
- [备忘录模式]()
- [状态模式]()
- [访问者模式]()
- [中介者模式]()
- [解释器模式]()


## 总结

设计模式就是代码写的多的套路，看懂这些模式很简单，但是学以制用才是本事。作为初学者还是要多去看别人优秀的代码怎么写的。个人认为学习设计模式的目的只有一个，那就是写出高质量的代码。
